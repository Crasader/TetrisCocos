// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_message_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsTetromino_ColorImpl();
void InitDefaultsTetromino_Color();
void InitDefaultsTetromino_PosImpl();
void InitDefaultsTetromino_Pos();
void InitDefaultsTetrominoImpl();
void InitDefaultsTetromino();
void InitDefaultsSolidBlocksImpl();
void InitDefaultsSolidBlocks();
void InitDefaultsBoardImpl();
void InitDefaultsBoard();
inline void InitDefaults() {
  InitDefaultsTetromino_Color();
  InitDefaultsTetromino_Pos();
  InitDefaultsTetromino();
  InitDefaultsSolidBlocks();
  InitDefaultsBoard();
}
}  // namespace protobuf_message_2eproto
namespace tetris {
namespace proto {
class Board;
class BoardDefaultTypeInternal;
extern BoardDefaultTypeInternal _Board_default_instance_;
class SolidBlocks;
class SolidBlocksDefaultTypeInternal;
extern SolidBlocksDefaultTypeInternal _SolidBlocks_default_instance_;
class Tetromino;
class TetrominoDefaultTypeInternal;
extern TetrominoDefaultTypeInternal _Tetromino_default_instance_;
class Tetromino_Color;
class Tetromino_ColorDefaultTypeInternal;
extern Tetromino_ColorDefaultTypeInternal _Tetromino_Color_default_instance_;
class Tetromino_Pos;
class Tetromino_PosDefaultTypeInternal;
extern Tetromino_PosDefaultTypeInternal _Tetromino_Pos_default_instance_;
}  // namespace proto
}  // namespace tetris
namespace tetris {
namespace proto {

enum Board_MessageType {
  Board_MessageType_GAME_OVER_SIGNAL = 0,
  Board_MessageType_GAME_PAUSE_SIGNAL = 1,
  Board_MessageType_GAME_START_SIGNAL = 3,
  Board_MessageType_GAME_RESUME_SIGNAL = 4,
  Board_MessageType_ENTIRE_BOARD_STATE = 5,
  Board_MessageType_MOVING_TETROMINO_STATE = 6,
  Board_MessageType_Board_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Board_MessageType_Board_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Board_MessageType_IsValid(int value);
const Board_MessageType Board_MessageType_MessageType_MIN = Board_MessageType_GAME_OVER_SIGNAL;
const Board_MessageType Board_MessageType_MessageType_MAX = Board_MessageType_MOVING_TETROMINO_STATE;
const int Board_MessageType_MessageType_ARRAYSIZE = Board_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Board_MessageType_descriptor();
inline const ::std::string& Board_MessageType_Name(Board_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Board_MessageType_descriptor(), value);
}
inline bool Board_MessageType_Parse(
    const ::std::string& name, Board_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Board_MessageType>(
    Board_MessageType_descriptor(), name, value);
}
// ===================================================================

class Tetromino_Color : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tetris.proto.Tetromino.Color) */ {
 public:
  Tetromino_Color();
  virtual ~Tetromino_Color();

  Tetromino_Color(const Tetromino_Color& from);

  inline Tetromino_Color& operator=(const Tetromino_Color& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Tetromino_Color(Tetromino_Color&& from) noexcept
    : Tetromino_Color() {
    *this = ::std::move(from);
  }

  inline Tetromino_Color& operator=(Tetromino_Color&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tetromino_Color& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tetromino_Color* internal_default_instance() {
    return reinterpret_cast<const Tetromino_Color*>(
               &_Tetromino_Color_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Tetromino_Color* other);
  friend void swap(Tetromino_Color& a, Tetromino_Color& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tetromino_Color* New() const PROTOBUF_FINAL { return New(NULL); }

  Tetromino_Color* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Tetromino_Color& from);
  void MergeFrom(const Tetromino_Color& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Tetromino_Color* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float r = 1;
  void clear_r();
  static const int kRFieldNumber = 1;
  float r() const;
  void set_r(float value);

  // float g = 2;
  void clear_g();
  static const int kGFieldNumber = 2;
  float g() const;
  void set_g(float value);

  // float b = 3;
  void clear_b();
  static const int kBFieldNumber = 3;
  float b() const;
  void set_b(float value);

  // float a = 4;
  void clear_a();
  static const int kAFieldNumber = 4;
  float a() const;
  void set_a(float value);

  // @@protoc_insertion_point(class_scope:tetris.proto.Tetromino.Color)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float r_;
  float g_;
  float b_;
  float a_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsTetromino_ColorImpl();
};
// -------------------------------------------------------------------

class Tetromino_Pos : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tetris.proto.Tetromino.Pos) */ {
 public:
  Tetromino_Pos();
  virtual ~Tetromino_Pos();

  Tetromino_Pos(const Tetromino_Pos& from);

  inline Tetromino_Pos& operator=(const Tetromino_Pos& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Tetromino_Pos(Tetromino_Pos&& from) noexcept
    : Tetromino_Pos() {
    *this = ::std::move(from);
  }

  inline Tetromino_Pos& operator=(Tetromino_Pos&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tetromino_Pos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tetromino_Pos* internal_default_instance() {
    return reinterpret_cast<const Tetromino_Pos*>(
               &_Tetromino_Pos_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Tetromino_Pos* other);
  friend void swap(Tetromino_Pos& a, Tetromino_Pos& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tetromino_Pos* New() const PROTOBUF_FINAL { return New(NULL); }

  Tetromino_Pos* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Tetromino_Pos& from);
  void MergeFrom(const Tetromino_Pos& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Tetromino_Pos* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // int32 y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tetris.proto.Tetromino.Pos)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsTetromino_PosImpl();
};
// -------------------------------------------------------------------

class Tetromino : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tetris.proto.Tetromino) */ {
 public:
  Tetromino();
  virtual ~Tetromino();

  Tetromino(const Tetromino& from);

  inline Tetromino& operator=(const Tetromino& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Tetromino(Tetromino&& from) noexcept
    : Tetromino() {
    *this = ::std::move(from);
  }

  inline Tetromino& operator=(Tetromino&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Tetromino& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Tetromino* internal_default_instance() {
    return reinterpret_cast<const Tetromino*>(
               &_Tetromino_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Tetromino* other);
  friend void swap(Tetromino& a, Tetromino& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Tetromino* New() const PROTOBUF_FINAL { return New(NULL); }

  Tetromino* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Tetromino& from);
  void MergeFrom(const Tetromino& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Tetromino* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Tetromino_Color Color;
  typedef Tetromino_Pos Pos;

  // accessors -------------------------------------------------------

  // repeated .tetris.proto.Tetromino.Pos unitBlocksVec = 4;
  int unitblocksvec_size() const;
  void clear_unitblocksvec();
  static const int kUnitBlocksVecFieldNumber = 4;
  const ::tetris::proto::Tetromino_Pos& unitblocksvec(int index) const;
  ::tetris::proto::Tetromino_Pos* mutable_unitblocksvec(int index);
  ::tetris::proto::Tetromino_Pos* add_unitblocksvec();
  ::google::protobuf::RepeatedPtrField< ::tetris::proto::Tetromino_Pos >*
      mutable_unitblocksvec();
  const ::google::protobuf::RepeatedPtrField< ::tetris::proto::Tetromino_Pos >&
      unitblocksvec() const;

  // .tetris.proto.Tetromino.Color color = 1;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 1;
  const ::tetris::proto::Tetromino_Color& color() const;
  ::tetris::proto::Tetromino_Color* release_color();
  ::tetris::proto::Tetromino_Color* mutable_color();
  void set_allocated_color(::tetris::proto::Tetromino_Color* color);

  // .tetris.proto.Tetromino.Color borderColor = 2;
  bool has_bordercolor() const;
  void clear_bordercolor();
  static const int kBorderColorFieldNumber = 2;
  const ::tetris::proto::Tetromino_Color& bordercolor() const;
  ::tetris::proto::Tetromino_Color* release_bordercolor();
  ::tetris::proto::Tetromino_Color* mutable_bordercolor();
  void set_allocated_bordercolor(::tetris::proto::Tetromino_Color* bordercolor);

  // .tetris.proto.Tetromino.Pos gridMatrixPoint = 3;
  bool has_gridmatrixpoint() const;
  void clear_gridmatrixpoint();
  static const int kGridMatrixPointFieldNumber = 3;
  const ::tetris::proto::Tetromino_Pos& gridmatrixpoint() const;
  ::tetris::proto::Tetromino_Pos* release_gridmatrixpoint();
  ::tetris::proto::Tetromino_Pos* mutable_gridmatrixpoint();
  void set_allocated_gridmatrixpoint(::tetris::proto::Tetromino_Pos* gridmatrixpoint);

  // @@protoc_insertion_point(class_scope:tetris.proto.Tetromino)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tetris::proto::Tetromino_Pos > unitblocksvec_;
  ::tetris::proto::Tetromino_Color* color_;
  ::tetris::proto::Tetromino_Color* bordercolor_;
  ::tetris::proto::Tetromino_Pos* gridmatrixpoint_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsTetrominoImpl();
};
// -------------------------------------------------------------------

class SolidBlocks : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tetris.proto.SolidBlocks) */ {
 public:
  SolidBlocks();
  virtual ~SolidBlocks();

  SolidBlocks(const SolidBlocks& from);

  inline SolidBlocks& operator=(const SolidBlocks& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SolidBlocks(SolidBlocks&& from) noexcept
    : SolidBlocks() {
    *this = ::std::move(from);
  }

  inline SolidBlocks& operator=(SolidBlocks&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SolidBlocks& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SolidBlocks* internal_default_instance() {
    return reinterpret_cast<const SolidBlocks*>(
               &_SolidBlocks_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(SolidBlocks* other);
  friend void swap(SolidBlocks& a, SolidBlocks& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SolidBlocks* New() const PROTOBUF_FINAL { return New(NULL); }

  SolidBlocks* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SolidBlocks& from);
  void MergeFrom(const SolidBlocks& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SolidBlocks* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tetris.proto.Tetromino tetrominos = 1;
  int tetrominos_size() const;
  void clear_tetrominos();
  static const int kTetrominosFieldNumber = 1;
  const ::tetris::proto::Tetromino& tetrominos(int index) const;
  ::tetris::proto::Tetromino* mutable_tetrominos(int index);
  ::tetris::proto::Tetromino* add_tetrominos();
  ::google::protobuf::RepeatedPtrField< ::tetris::proto::Tetromino >*
      mutable_tetrominos();
  const ::google::protobuf::RepeatedPtrField< ::tetris::proto::Tetromino >&
      tetrominos() const;

  // @@protoc_insertion_point(class_scope:tetris.proto.SolidBlocks)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tetris::proto::Tetromino > tetrominos_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsSolidBlocksImpl();
};
// -------------------------------------------------------------------

class Board : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tetris.proto.Board) */ {
 public:
  Board();
  virtual ~Board();

  Board(const Board& from);

  inline Board& operator=(const Board& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Board(Board&& from) noexcept
    : Board() {
    *this = ::std::move(from);
  }

  inline Board& operator=(Board&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Board& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Board* internal_default_instance() {
    return reinterpret_cast<const Board*>(
               &_Board_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Board* other);
  friend void swap(Board& a, Board& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Board* New() const PROTOBUF_FINAL { return New(NULL); }

  Board* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Board& from);
  void MergeFrom(const Board& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Board* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Board_MessageType MessageType;
  static const MessageType GAME_OVER_SIGNAL =
    Board_MessageType_GAME_OVER_SIGNAL;
  static const MessageType GAME_PAUSE_SIGNAL =
    Board_MessageType_GAME_PAUSE_SIGNAL;
  static const MessageType GAME_START_SIGNAL =
    Board_MessageType_GAME_START_SIGNAL;
  static const MessageType GAME_RESUME_SIGNAL =
    Board_MessageType_GAME_RESUME_SIGNAL;
  static const MessageType ENTIRE_BOARD_STATE =
    Board_MessageType_ENTIRE_BOARD_STATE;
  static const MessageType MOVING_TETROMINO_STATE =
    Board_MessageType_MOVING_TETROMINO_STATE;
  static inline bool MessageType_IsValid(int value) {
    return Board_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    Board_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    Board_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    Board_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return Board_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return Board_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return Board_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .tetris.proto.Tetromino movingTet = 4;
  bool has_movingtet() const;
  void clear_movingtet();
  static const int kMovingTetFieldNumber = 4;
  const ::tetris::proto::Tetromino& movingtet() const;
  ::tetris::proto::Tetromino* release_movingtet();
  ::tetris::proto::Tetromino* mutable_movingtet();
  void set_allocated_movingtet(::tetris::proto::Tetromino* movingtet);

  // .tetris.proto.SolidBlocks solidBlocks = 5;
  bool has_solidblocks() const;
  void clear_solidblocks();
  static const int kSolidBlocksFieldNumber = 5;
  const ::tetris::proto::SolidBlocks& solidblocks() const;
  ::tetris::proto::SolidBlocks* release_solidblocks();
  ::tetris::proto::SolidBlocks* mutable_solidblocks();
  void set_allocated_solidblocks(::tetris::proto::SolidBlocks* solidblocks);

  // .tetris.proto.Board.MessageType messageType = 1;
  void clear_messagetype();
  static const int kMessageTypeFieldNumber = 1;
  ::tetris::proto::Board_MessageType messagetype() const;
  void set_messagetype(::tetris::proto::Board_MessageType value);

  // int32 score = 2;
  void clear_score();
  static const int kScoreFieldNumber = 2;
  ::google::protobuf::int32 score() const;
  void set_score(::google::protobuf::int32 value);

  // int32 level = 3;
  void clear_level();
  static const int kLevelFieldNumber = 3;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tetris.proto.Board)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tetris::proto::Tetromino* movingtet_;
  ::tetris::proto::SolidBlocks* solidblocks_;
  int messagetype_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 level_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsBoardImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Tetromino_Color

// float r = 1;
inline void Tetromino_Color::clear_r() {
  r_ = 0;
}
inline float Tetromino_Color::r() const {
  // @@protoc_insertion_point(field_get:tetris.proto.Tetromino.Color.r)
  return r_;
}
inline void Tetromino_Color::set_r(float value) {
  
  r_ = value;
  // @@protoc_insertion_point(field_set:tetris.proto.Tetromino.Color.r)
}

// float g = 2;
inline void Tetromino_Color::clear_g() {
  g_ = 0;
}
inline float Tetromino_Color::g() const {
  // @@protoc_insertion_point(field_get:tetris.proto.Tetromino.Color.g)
  return g_;
}
inline void Tetromino_Color::set_g(float value) {
  
  g_ = value;
  // @@protoc_insertion_point(field_set:tetris.proto.Tetromino.Color.g)
}

// float b = 3;
inline void Tetromino_Color::clear_b() {
  b_ = 0;
}
inline float Tetromino_Color::b() const {
  // @@protoc_insertion_point(field_get:tetris.proto.Tetromino.Color.b)
  return b_;
}
inline void Tetromino_Color::set_b(float value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:tetris.proto.Tetromino.Color.b)
}

// float a = 4;
inline void Tetromino_Color::clear_a() {
  a_ = 0;
}
inline float Tetromino_Color::a() const {
  // @@protoc_insertion_point(field_get:tetris.proto.Tetromino.Color.a)
  return a_;
}
inline void Tetromino_Color::set_a(float value) {
  
  a_ = value;
  // @@protoc_insertion_point(field_set:tetris.proto.Tetromino.Color.a)
}

// -------------------------------------------------------------------

// Tetromino_Pos

// int32 x = 1;
inline void Tetromino_Pos::clear_x() {
  x_ = 0;
}
inline ::google::protobuf::int32 Tetromino_Pos::x() const {
  // @@protoc_insertion_point(field_get:tetris.proto.Tetromino.Pos.x)
  return x_;
}
inline void Tetromino_Pos::set_x(::google::protobuf::int32 value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:tetris.proto.Tetromino.Pos.x)
}

// int32 y = 2;
inline void Tetromino_Pos::clear_y() {
  y_ = 0;
}
inline ::google::protobuf::int32 Tetromino_Pos::y() const {
  // @@protoc_insertion_point(field_get:tetris.proto.Tetromino.Pos.y)
  return y_;
}
inline void Tetromino_Pos::set_y(::google::protobuf::int32 value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:tetris.proto.Tetromino.Pos.y)
}

// -------------------------------------------------------------------

// Tetromino

// .tetris.proto.Tetromino.Color color = 1;
inline bool Tetromino::has_color() const {
  return this != internal_default_instance() && color_ != NULL;
}
inline void Tetromino::clear_color() {
  if (GetArenaNoVirtual() == NULL && color_ != NULL) {
    delete color_;
  }
  color_ = NULL;
}
inline const ::tetris::proto::Tetromino_Color& Tetromino::color() const {
  const ::tetris::proto::Tetromino_Color* p = color_;
  // @@protoc_insertion_point(field_get:tetris.proto.Tetromino.color)
  return p != NULL ? *p : *reinterpret_cast<const ::tetris::proto::Tetromino_Color*>(
      &::tetris::proto::_Tetromino_Color_default_instance_);
}
inline ::tetris::proto::Tetromino_Color* Tetromino::release_color() {
  // @@protoc_insertion_point(field_release:tetris.proto.Tetromino.color)
  
  ::tetris::proto::Tetromino_Color* temp = color_;
  color_ = NULL;
  return temp;
}
inline ::tetris::proto::Tetromino_Color* Tetromino::mutable_color() {
  
  if (color_ == NULL) {
    color_ = new ::tetris::proto::Tetromino_Color;
  }
  // @@protoc_insertion_point(field_mutable:tetris.proto.Tetromino.color)
  return color_;
}
inline void Tetromino::set_allocated_color(::tetris::proto::Tetromino_Color* color) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete color_;
  }
  if (color) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      color = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:tetris.proto.Tetromino.color)
}

// .tetris.proto.Tetromino.Color borderColor = 2;
inline bool Tetromino::has_bordercolor() const {
  return this != internal_default_instance() && bordercolor_ != NULL;
}
inline void Tetromino::clear_bordercolor() {
  if (GetArenaNoVirtual() == NULL && bordercolor_ != NULL) {
    delete bordercolor_;
  }
  bordercolor_ = NULL;
}
inline const ::tetris::proto::Tetromino_Color& Tetromino::bordercolor() const {
  const ::tetris::proto::Tetromino_Color* p = bordercolor_;
  // @@protoc_insertion_point(field_get:tetris.proto.Tetromino.borderColor)
  return p != NULL ? *p : *reinterpret_cast<const ::tetris::proto::Tetromino_Color*>(
      &::tetris::proto::_Tetromino_Color_default_instance_);
}
inline ::tetris::proto::Tetromino_Color* Tetromino::release_bordercolor() {
  // @@protoc_insertion_point(field_release:tetris.proto.Tetromino.borderColor)
  
  ::tetris::proto::Tetromino_Color* temp = bordercolor_;
  bordercolor_ = NULL;
  return temp;
}
inline ::tetris::proto::Tetromino_Color* Tetromino::mutable_bordercolor() {
  
  if (bordercolor_ == NULL) {
    bordercolor_ = new ::tetris::proto::Tetromino_Color;
  }
  // @@protoc_insertion_point(field_mutable:tetris.proto.Tetromino.borderColor)
  return bordercolor_;
}
inline void Tetromino::set_allocated_bordercolor(::tetris::proto::Tetromino_Color* bordercolor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bordercolor_;
  }
  if (bordercolor) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bordercolor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bordercolor, submessage_arena);
    }
    
  } else {
    
  }
  bordercolor_ = bordercolor;
  // @@protoc_insertion_point(field_set_allocated:tetris.proto.Tetromino.borderColor)
}

// .tetris.proto.Tetromino.Pos gridMatrixPoint = 3;
inline bool Tetromino::has_gridmatrixpoint() const {
  return this != internal_default_instance() && gridmatrixpoint_ != NULL;
}
inline void Tetromino::clear_gridmatrixpoint() {
  if (GetArenaNoVirtual() == NULL && gridmatrixpoint_ != NULL) {
    delete gridmatrixpoint_;
  }
  gridmatrixpoint_ = NULL;
}
inline const ::tetris::proto::Tetromino_Pos& Tetromino::gridmatrixpoint() const {
  const ::tetris::proto::Tetromino_Pos* p = gridmatrixpoint_;
  // @@protoc_insertion_point(field_get:tetris.proto.Tetromino.gridMatrixPoint)
  return p != NULL ? *p : *reinterpret_cast<const ::tetris::proto::Tetromino_Pos*>(
      &::tetris::proto::_Tetromino_Pos_default_instance_);
}
inline ::tetris::proto::Tetromino_Pos* Tetromino::release_gridmatrixpoint() {
  // @@protoc_insertion_point(field_release:tetris.proto.Tetromino.gridMatrixPoint)
  
  ::tetris::proto::Tetromino_Pos* temp = gridmatrixpoint_;
  gridmatrixpoint_ = NULL;
  return temp;
}
inline ::tetris::proto::Tetromino_Pos* Tetromino::mutable_gridmatrixpoint() {
  
  if (gridmatrixpoint_ == NULL) {
    gridmatrixpoint_ = new ::tetris::proto::Tetromino_Pos;
  }
  // @@protoc_insertion_point(field_mutable:tetris.proto.Tetromino.gridMatrixPoint)
  return gridmatrixpoint_;
}
inline void Tetromino::set_allocated_gridmatrixpoint(::tetris::proto::Tetromino_Pos* gridmatrixpoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete gridmatrixpoint_;
  }
  if (gridmatrixpoint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      gridmatrixpoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, gridmatrixpoint, submessage_arena);
    }
    
  } else {
    
  }
  gridmatrixpoint_ = gridmatrixpoint;
  // @@protoc_insertion_point(field_set_allocated:tetris.proto.Tetromino.gridMatrixPoint)
}

// repeated .tetris.proto.Tetromino.Pos unitBlocksVec = 4;
inline int Tetromino::unitblocksvec_size() const {
  return unitblocksvec_.size();
}
inline void Tetromino::clear_unitblocksvec() {
  unitblocksvec_.Clear();
}
inline const ::tetris::proto::Tetromino_Pos& Tetromino::unitblocksvec(int index) const {
  // @@protoc_insertion_point(field_get:tetris.proto.Tetromino.unitBlocksVec)
  return unitblocksvec_.Get(index);
}
inline ::tetris::proto::Tetromino_Pos* Tetromino::mutable_unitblocksvec(int index) {
  // @@protoc_insertion_point(field_mutable:tetris.proto.Tetromino.unitBlocksVec)
  return unitblocksvec_.Mutable(index);
}
inline ::tetris::proto::Tetromino_Pos* Tetromino::add_unitblocksvec() {
  // @@protoc_insertion_point(field_add:tetris.proto.Tetromino.unitBlocksVec)
  return unitblocksvec_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tetris::proto::Tetromino_Pos >*
Tetromino::mutable_unitblocksvec() {
  // @@protoc_insertion_point(field_mutable_list:tetris.proto.Tetromino.unitBlocksVec)
  return &unitblocksvec_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tetris::proto::Tetromino_Pos >&
Tetromino::unitblocksvec() const {
  // @@protoc_insertion_point(field_list:tetris.proto.Tetromino.unitBlocksVec)
  return unitblocksvec_;
}

// -------------------------------------------------------------------

// SolidBlocks

// repeated .tetris.proto.Tetromino tetrominos = 1;
inline int SolidBlocks::tetrominos_size() const {
  return tetrominos_.size();
}
inline void SolidBlocks::clear_tetrominos() {
  tetrominos_.Clear();
}
inline const ::tetris::proto::Tetromino& SolidBlocks::tetrominos(int index) const {
  // @@protoc_insertion_point(field_get:tetris.proto.SolidBlocks.tetrominos)
  return tetrominos_.Get(index);
}
inline ::tetris::proto::Tetromino* SolidBlocks::mutable_tetrominos(int index) {
  // @@protoc_insertion_point(field_mutable:tetris.proto.SolidBlocks.tetrominos)
  return tetrominos_.Mutable(index);
}
inline ::tetris::proto::Tetromino* SolidBlocks::add_tetrominos() {
  // @@protoc_insertion_point(field_add:tetris.proto.SolidBlocks.tetrominos)
  return tetrominos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tetris::proto::Tetromino >*
SolidBlocks::mutable_tetrominos() {
  // @@protoc_insertion_point(field_mutable_list:tetris.proto.SolidBlocks.tetrominos)
  return &tetrominos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tetris::proto::Tetromino >&
SolidBlocks::tetrominos() const {
  // @@protoc_insertion_point(field_list:tetris.proto.SolidBlocks.tetrominos)
  return tetrominos_;
}

// -------------------------------------------------------------------

// Board

// .tetris.proto.Board.MessageType messageType = 1;
inline void Board::clear_messagetype() {
  messagetype_ = 0;
}
inline ::tetris::proto::Board_MessageType Board::messagetype() const {
  // @@protoc_insertion_point(field_get:tetris.proto.Board.messageType)
  return static_cast< ::tetris::proto::Board_MessageType >(messagetype_);
}
inline void Board::set_messagetype(::tetris::proto::Board_MessageType value) {
  
  messagetype_ = value;
  // @@protoc_insertion_point(field_set:tetris.proto.Board.messageType)
}

// int32 score = 2;
inline void Board::clear_score() {
  score_ = 0;
}
inline ::google::protobuf::int32 Board::score() const {
  // @@protoc_insertion_point(field_get:tetris.proto.Board.score)
  return score_;
}
inline void Board::set_score(::google::protobuf::int32 value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:tetris.proto.Board.score)
}

// int32 level = 3;
inline void Board::clear_level() {
  level_ = 0;
}
inline ::google::protobuf::int32 Board::level() const {
  // @@protoc_insertion_point(field_get:tetris.proto.Board.level)
  return level_;
}
inline void Board::set_level(::google::protobuf::int32 value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:tetris.proto.Board.level)
}

// .tetris.proto.Tetromino movingTet = 4;
inline bool Board::has_movingtet() const {
  return this != internal_default_instance() && movingtet_ != NULL;
}
inline void Board::clear_movingtet() {
  if (GetArenaNoVirtual() == NULL && movingtet_ != NULL) {
    delete movingtet_;
  }
  movingtet_ = NULL;
}
inline const ::tetris::proto::Tetromino& Board::movingtet() const {
  const ::tetris::proto::Tetromino* p = movingtet_;
  // @@protoc_insertion_point(field_get:tetris.proto.Board.movingTet)
  return p != NULL ? *p : *reinterpret_cast<const ::tetris::proto::Tetromino*>(
      &::tetris::proto::_Tetromino_default_instance_);
}
inline ::tetris::proto::Tetromino* Board::release_movingtet() {
  // @@protoc_insertion_point(field_release:tetris.proto.Board.movingTet)
  
  ::tetris::proto::Tetromino* temp = movingtet_;
  movingtet_ = NULL;
  return temp;
}
inline ::tetris::proto::Tetromino* Board::mutable_movingtet() {
  
  if (movingtet_ == NULL) {
    movingtet_ = new ::tetris::proto::Tetromino;
  }
  // @@protoc_insertion_point(field_mutable:tetris.proto.Board.movingTet)
  return movingtet_;
}
inline void Board::set_allocated_movingtet(::tetris::proto::Tetromino* movingtet) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete movingtet_;
  }
  if (movingtet) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      movingtet = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, movingtet, submessage_arena);
    }
    
  } else {
    
  }
  movingtet_ = movingtet;
  // @@protoc_insertion_point(field_set_allocated:tetris.proto.Board.movingTet)
}

// .tetris.proto.SolidBlocks solidBlocks = 5;
inline bool Board::has_solidblocks() const {
  return this != internal_default_instance() && solidblocks_ != NULL;
}
inline void Board::clear_solidblocks() {
  if (GetArenaNoVirtual() == NULL && solidblocks_ != NULL) {
    delete solidblocks_;
  }
  solidblocks_ = NULL;
}
inline const ::tetris::proto::SolidBlocks& Board::solidblocks() const {
  const ::tetris::proto::SolidBlocks* p = solidblocks_;
  // @@protoc_insertion_point(field_get:tetris.proto.Board.solidBlocks)
  return p != NULL ? *p : *reinterpret_cast<const ::tetris::proto::SolidBlocks*>(
      &::tetris::proto::_SolidBlocks_default_instance_);
}
inline ::tetris::proto::SolidBlocks* Board::release_solidblocks() {
  // @@protoc_insertion_point(field_release:tetris.proto.Board.solidBlocks)
  
  ::tetris::proto::SolidBlocks* temp = solidblocks_;
  solidblocks_ = NULL;
  return temp;
}
inline ::tetris::proto::SolidBlocks* Board::mutable_solidblocks() {
  
  if (solidblocks_ == NULL) {
    solidblocks_ = new ::tetris::proto::SolidBlocks;
  }
  // @@protoc_insertion_point(field_mutable:tetris.proto.Board.solidBlocks)
  return solidblocks_;
}
inline void Board::set_allocated_solidblocks(::tetris::proto::SolidBlocks* solidblocks) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete solidblocks_;
  }
  if (solidblocks) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      solidblocks = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, solidblocks, submessage_arena);
    }
    
  } else {
    
  }
  solidblocks_ = solidblocks;
  // @@protoc_insertion_point(field_set_allocated:tetris.proto.Board.solidBlocks)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace tetris

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::tetris::proto::Board_MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tetris::proto::Board_MessageType>() {
  return ::tetris::proto::Board_MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
